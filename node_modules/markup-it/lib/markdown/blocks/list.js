'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _trimTrailingLines = require('trim-trailing-lines');

var _trimTrailingLines2 = _interopRequireDefault(_trimTrailingLines);

var _indentString = require('indent-string');

var _indentString2 = _interopRequireDefault(_indentString);

var _ = require('../../');

var _block = require('../re/block');

var _block2 = _interopRequireDefault(_block);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Serialize a list to markdown
 * @type {Serializer}
 */
var serialize = (0, _.Serializer)().matchType([_.BLOCKS.UL_LIST, _.BLOCKS.OL_LIST]).then(function (state) {
    var list = state.peek();
    var nodes = list.nodes;


    var output = nodes.map(function (item, index) {
        return serializeListItem(state, list, item, index);
    }).join('');

    return state.shift().write(output);
});

/**
 * Deserialize a list to a node.
 * @type {Deserializer}
 */
var deserialize = (0, _.Deserializer)().matchRegExp(_block2.default.list.block, function (state, match) {
    var rawList = match[0];
    var bull = match[2];
    var ordered = bull.length > 1;

    var type = ordered ? _.BLOCKS.OL_LIST : _.BLOCKS.UL_LIST;

    var item = void 0;
    var loose = void 0;
    var data = void 0;
    var next = false;

    var lastIndex = 0;
    var nodes = [];
    var rawItem = void 0;
    var textItem = void 0;
    var space = void 0;
    var items = [];

    // Extract all items
    _block2.default.list.item.lastIndex = 0;
    do {
        item = _block2.default.list.item.exec(rawList);
        if (item !== null) {
            rawItem = rawList.slice(lastIndex, _block2.default.list.item.lastIndex);
            lastIndex = _block2.default.list.item.lastIndex;

            items.push([item, rawItem]);
        }
    } while (item !== null);

    for (var i = 0; i < items.length; i += 1) {
        item = items[i][0];
        rawItem = items[i][1];
        data = undefined;

        // Remove the list item's bullet
        // so it is seen as the next token.
        textItem = item[0];
        space = textItem.length;
        textItem = textItem.replace(_block2.default.list.bulletAndSpaces, '');

        // Parse tasklists
        var checked = _block2.default.list.checkbox.exec(textItem);
        if (checked) {
            checked = checked[1] === 'x';
            textItem = textItem.replace(_block2.default.list.checkbox, '');
            data = { checked: checked };
        }

        // Outdent whatever the
        // list item contains. Hacky.
        if (~textItem.indexOf('\n ')) {
            space -= textItem.length;
            textItem = textItem.replace(new RegExp('^ {1,' + space + '}', 'gm'), '');
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(textItem);
        if (i !== items.length - 1) {
            next = textItem.charAt(textItem.length - 1) === '\n';
            if (!loose) loose = next;
        }

        var nodeItem = _.Block.create({
            type: _.BLOCKS.LIST_ITEM,
            data: data,
            nodes: (loose ? state.setProp('looseList', state.depth) : state).use('block').deserialize(textItem)
        });

        nodes.push(nodeItem);
    }

    var listBlock = _.Block.create({
        type: type,
        nodes: nodes
    });

    return state.push(listBlock);
});

/**
 * Serialize a list item to markdown.
 * @param  {State} state
 * @param  {Block} list
 * @param  {Block} item
 * @param  {Number} index
 * @return {String} output
 */
function serializeListItem(state, list, item, index) {
    // Is it a task item ?
    var hasChecked = item.data.has('checked');
    var isChecked = item.data.get('checked');

    // Is it a loose list?
    var loose = item.nodes.some(function (child) {
        return child.type === _.BLOCKS.PARAGRAPH;
    });

    // Is it the last item from the list?
    var last = list.nodes.size - 1 === index;

    // Calcul bullet to use
    var bullet = list.type === _.BLOCKS.OL_LIST ? index + 1 + '.' : '*';

    // Indent all lignes
    var indent = bullet.length + 1;
    var body = state.use('block').serialize(item.nodes);
    // Remove unwanted empty lines added by sub-blocks
    body = (0, _trimTrailingLines2.default)(body) + '\n';

    body = (0, _indentString2.default)(body, ' ', indent).slice(indent);

    if (loose || last) {
        // Add empty line
        body += '\n';
    }

    if (hasChecked) {
        body = (isChecked ? '[x]' : '[ ]') + ' ' + body;
    }

    return bullet + ' ' + body;
}

exports.default = { serialize: serialize, deserialize: deserialize };