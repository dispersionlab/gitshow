'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _ = require('../../');

var _heading = require('../re/heading');

var _heading2 = _interopRequireDefault(_heading);

var _escape = require('../../html/escape');

var _escape2 = _interopRequireDefault(_escape);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TYPES = [_.BLOCKS.HEADING_1, _.BLOCKS.HEADING_2, _.BLOCKS.HEADING_3, _.BLOCKS.HEADING_4, _.BLOCKS.HEADING_5, _.BLOCKS.HEADING_6];

/**
 * Serialize an heading node to markdown
 * @type {Serializer}
 */
var serialize = (0, _.Serializer)().matchType(TYPES).then(function (state) {
    var node = state.peek();
    var type = node.type,
        data = node.data;

    var id = data.get('id');
    var depth = TYPES.indexOf(type);
    var prefix = Array(depth + 2).join('#');

    var inner = state.use('inline').serialize(node.nodes);
    if (id) {
        inner = inner + ' <a id="' + (0, _escape2.default)(id) + '"></a>';
    }

    return state.shift().write(prefix + ' ' + inner + '\n\n');
});

/**
 * Deserialize a normal heading (starting with "#..") and headings using
 * line syntax to a node.
 * @type {Deserializer}
 */
var deserializeNormal = (0, _.Deserializer)().matchRegExp(_heading2.default.normal, function (state, match) {
    var level = match[1].length;
    return parseHeadingText(state, level, match[2]);
});

/**
 * Deserialize a line heading.
 * @type {Deserializer}
 */
var deserializeLine = (0, _.Deserializer)().matchRegExp(_heading2.default.line, function (state, match) {
    var level = match[2] === '=' ? 1 : 2;
    return parseHeadingText(state, level, match[1]);
});

var deserialize = (0, _.Deserializer)().use([deserializeNormal, deserializeLine]);

/**
 * Trim text left on a List of Nodes
 * @param  {List<Node>} nodes
 * @return {List<Node>}
 */
function trimLeftNodesText(nodes) {
    if (nodes.size === 0) {
        return nodes;
    }

    var firstNode = nodes.first();
    // We don't want to trim complicated blocks
    if (firstNode.object !== 'text') {
        return nodes;
    }

    var leaves = firstNode.getLeaves();
    var firstLeaf = leaves.first();

    return nodes.rest().unshift(firstNode.setLeaves(leaves.rest().unshift(firstLeaf.merge({
        text: firstLeaf.text.trimLeft()
    }))));
}

/**
 * Trim text right on a List of Nodes
 * @param  {List<Node>} nodes
 * @return {List<Node>}
 */
function trimRightNodesText(nodes) {
    if (nodes.size === 0) {
        return nodes;
    }

    var lastNode = nodes.last();
    // We don't want to trim complicated blocks
    if (lastNode.object !== 'text') {
        return nodes;
    }

    var leaves = lastNode.getLeaves();
    var lastLeaf = leaves.last();

    return nodes.butLast().push(lastNode.setLeaves(leaves.butLast().push(lastLeaf.merge({
        text: lastLeaf.text.trimRight()
    }))));
}

/**
 * Parse inner text of header to extract ID entity
 * @param  {State} state
 * @param  {Number} level
 * @param  {String} initialText
 * @return {State}
 */
function parseHeadingText(state, level, initialText) {
    var text = initialText;
    _heading2.default.id.lastIndex = 0;
    var matchId = _heading2.default.id.exec(text);
    var data = void 0;

    if (matchId) {
        // Remove ID from text
        text = text.replace(matchId[0], '').trim();
    } else {
        text = text.trim();
    }

    var newState = state.down({ text: text }).use('inline').lex();

    // Use the custom ID, or use the id of the last anchor found (see anchors tests)
    var id = matchId && matchId[2] || newState.getProp('lastAnchorId') || null;
    if (id) {
        data = { id: id };
    }

    var trimmedLeftNodes = trimLeftNodesText(newState.nodes);
    var trimmedNodes = trimRightNodesText(trimmedLeftNodes);

    var node = _.Block.create({
        type: TYPES[level - 1],
        nodes: trimmedNodes,
        data: data
    });

    return newState.up()
    // We have consumed any anchor ID that was seen recently
    .setProp('lastAnchorId', null).push(node);
}

exports.default = { serialize: serialize, deserialize: deserialize };