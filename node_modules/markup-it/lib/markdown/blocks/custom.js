'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _immutable = require('immutable');

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _trimTrailingLines = require('trim-trailing-lines');

var _trimTrailingLines2 = _interopRequireDefault(_trimTrailingLines);

var _ = require('../../');

var _block = require('../re/block');

var _block2 = _interopRequireDefault(_block);

var _liquid = require('../liquid');

var _liquid2 = _interopRequireDefault(_liquid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Return true if a block type is a custom one.
 * @param  {String} tag
 * @return {Boolean}
 */
function isCustomType(type) {
    return type.indexOf('x-') === 0;
}

/**
 * Return liquid tag from a custom type.
 * @param  {String} type
 * @return {String} tag
 */
function getTagFromCustomType(type) {
    return type.slice(2);
}

/**
 * Return custom type from a liquid tag.
 * @param  {String} tag
 * @return {String} type
 */
function getCustomTypeFromTag(tag) {
    return 'x-' + tag;
}

/**
 * Return true if a type if the closing tag.
 * @param  {String} tag
 * @return {Boolean}
 */
function isClosingTag(tag) {
    return tag.indexOf('end') === 0;
}

/**
 * Return true if a type if the closing tag of another type
 * @param  {String} type
 * @return {Boolean}
 */
function isClosingTagFor(tag, forTag) {
    return tag.indexOf('end' + forTag) === 0;
}

/**
 * Wrap the given nodes in the default block
 * @param  {Array<Node>} nodes
 * @return {Block}
 */
function wrapInDefaultBlock(nodes) {
    return _.Block.create({
        type: _.BLOCKS.DEFAULT,
        nodes: nodes
    });
}

/**
 * Serialize a templating block to markdown
 * @type {Serializer}
 */
var serialize = (0, _.Serializer)().matchType(isCustomType).then(function (state) {
    var node = state.peek();
    var type = node.type,
        data = node.data;


    var startTag = _liquid2.default.stringifyTag({
        tag: getTagFromCustomType(type),
        data: data
    });

    var split = node.object == 'block' ? '\n' : '';
    var end = node.object == 'block' ? '\n\n' : '';

    if (node.isVoid || node.nodes.isEmpty()) {
        (0, _warning2.default)(node.isVoid, 'Encountered a non-void custom block with no children');

        return state.shift().write('' + startTag + end);
    }

    var containsInline = node.nodes.first().object !== 'block';
    (0, _warning2.default)(!containsInline, 'Encountered a custom block containing inlines');

    var innerNodes = containsInline ? (0, _immutable.List)([wrapInDefaultBlock(node.nodes)]) : node.nodes;

    var inner = (0, _trimTrailingLines2.default)(state.serialize(innerNodes));

    var unendingTags = state.getProp('unendingTags') || (0, _immutable.List)();
    var endTag = unendingTags.includes(getTagFromCustomType(node.type)) ? '' : _liquid2.default.stringifyTag({
        tag: 'end' + getTagFromCustomType(node.type)
    });

    return state.shift().write('' + startTag + split + inner + split + endTag + end);
});

/**
 * Deserialize a templating block to a node.
 * @type {Deserializer}
 */
var deserialize = (0, _.Deserializer)().matchRegExp(_block2.default.customBlock, function (initialState, match) {
    var state = initialState;

    if (state.getProp('template') === false) {
        return undefined;
    }

    var text = match[1].trim();
    if (!text) {
        return state;
    }

    var parsed = _liquid2.default.parseTag(text);
    if (!parsed) {
        return state;
    }
    var tag = parsed.tag,
        data = parsed.data;


    var node = _.Block.create({
        type: getCustomTypeFromTag(tag),
        data: data,
        isVoid: true,
        nodes: (0, _immutable.List)()
    });

    // This node is temporary
    if (isClosingTag(tag)) {
        return state.push(node);
    }

    // By default it'll add this node as a single node.
    state = state.push(node);

    // List of tags that don't have an end
    var unendingTags = state.getProp('unendingTags') || (0, _immutable.List)();

    var resultState = state.lex({
        stopAt: function stopAt(newState) {
            // What nodes have been added in this iteration?
            var added = newState.nodes.skip(state.nodes.size);
            var between = added.takeUntil(function (child) {
                // Some tags don't have an explicit end and thus
                // need a special treatment
                if (unendingTags.includes(tag)) {
                    return isCustomType(child.type) && (
                    // Closing custom tag close previous unending tags
                    isClosingTag(getTagFromCustomType(child.type)) ||
                    // Unending tag close previous unending tags
                    unendingTags.includes(getTagFromCustomType(child.type)));
                }

                return isCustomType(child.type) && isClosingTagFor(getTagFromCustomType(child.type), tag);
            });

            if (between.size == added.size) {
                return undefined;
            }

            // We skip the default node.
            var beforeNodes = state.nodes.butLast();
            var afterNodes = added.skip(between.size);

            return newState.merge({
                nodes: beforeNodes.push(node.merge({
                    isVoid: false,
                    nodes: between.size == 0 ? (0, _immutable.List)([state.genText()]) : between
                })).concat(afterNodes)
                // Filter out this node's closing tag
                .filterNot(function (child) {
                    return isCustomType(child.type) && isClosingTag(getTagFromCustomType(child.type)) &&
                    // Don't swallow others' closing node by ensuring
                    // we filter the one that matches the current one
                    isClosingTagFor(getTagFromCustomType(child.type), tag);
                })
            });
        }
    });

    return resultState;
});

exports.default = { serialize: serialize, deserialize: deserialize };