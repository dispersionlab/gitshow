'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slate = require('@gitbook/slate');

var _ = require('../../');

var _table = require('../re/table');

var _table2 = _interopRequireDefault(_table);

var _html = require('../../html');

var _html2 = _interopRequireDefault(_html);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Deserialize a table with no leading pipe (gfm) to a node.
 * @type {Deserializer}
 */
var deserializeNoPipe = (0, _.Deserializer)().matchRegExp(_table2.default.nptable, function (state, match) {
    // Get all non empty lines
    var lines = match[0].split('\n').filter(Boolean);
    var header = lines[0];
    var aligns = lines[1];
    var rows = lines.slice(2);

    var node = parseTable(state, header, aligns, rows);
    return state.push(node);
});

/**
 * Deserialize a normal table to a node.
 * @type {Deserializer}
 */
var deserializeNormal = (0, _.Deserializer)().matchRegExp(_table2.default.normal, function (state, match) {
    // Get all non empty lines
    var lines = match[0].split('\n').filter(Boolean);
    var header = lines[0];
    var aligns = lines[1];
    var rows = lines.slice(2);

    var node = parseTable(state, header, aligns, rows);
    return state.push(node);
});

/**
 * Serialize a table node to markdown
 * @type {Serializer}
 */
var serialize = (0, _.Serializer)().matchType(_.BLOCKS.TABLE).then(function (state) {
    var table = state.peek();

    if (mustSerializeAsHTML(table)) {
        // Serialize as HTML
        var htmlState = _.State.create(_html2.default);
        var htmlOutput = htmlState.serializeDocument(_slate.Document.create({
            nodes: [table]
        }));
        return state.shift().write(htmlOutput);
    }

    var data = table.data,
        nodes = table.nodes;

    var aligns = data.get('aligns');
    var headerRow = nodes.get(0);
    var bodyRows = nodes.slice(1);

    var output = rowToText(state, headerRow) + '\n' + alignsToText(aligns) + '\n' + bodyRows.map(function (row) {
        return rowToText(state, row);
    }).join('\n') + '\n\n';

    return state.shift().write(output);
});

var deserialize = (0, _.Deserializer)().use([deserializeNoPipe, deserializeNormal]);

/**
 * Parse a table into a node.
 * @param  {State} state
 * @param  {String} headerStr
 * @param  {String} alignsStr The line containing the column aligns
 * @param  {String} rowStrs
 * @return {Block} table
 */
function parseTable(state, headerStr, alignsStr, rowStrs) {
    // Header
    var headerRow = parseRow(state, headerStr);

    // Rows
    var rowTokens = rowStrs.map(function (rowStr) {
        return parseRow(state, rowStr);
    });

    // Align for columns
    var alignsCells = rowToCells(alignsStr);
    var aligns = mapAligns(alignsCells);

    return _.Block.create({
        type: _.BLOCKS.TABLE,
        data: { aligns: aligns },
        nodes: [headerRow].concat(rowTokens)
    });
}

/**
 * Parse a row from a table into a row node.
 *
 * @param {State} state
 * @param {String} row
 * @return {Node}
 */
function parseRow(state, row) {
    // Split into cells
    var cells = rowToCells(row);

    // Tokenize each cell
    var cellNodes = cells.map(function (cell) {
        var text = cell.trim();
        var nodes = state.use('inline').deserialize(text);

        var paragraph = _.Block.create({
            type: _.BLOCKS.PARAGRAPH,
            nodes: nodes
        });

        return _.Block.create({
            type: _.BLOCKS.TABLE_CELL,
            nodes: [paragraph]
        });
    });

    return _.Block.create({
        type: _.BLOCKS.TABLE_ROW,
        nodes: cellNodes
    });
}

/**
 * Split a row up into its individual cells
 *
 * @param {String} rowStr
 * @return {Array<String>}
 */
function rowToCells(rowStr) {
    var cells = [];
    var trimmed = rowStr.trim();

    var lastSep = 0;
    for (var i = 0; i < trimmed.length; i += 1) {
        var prevIdx = i === 0 ? 0 : i - 1;
        var isSep = trimmed[i] === '|';
        var isNotEscaped = trimmed[prevIdx] !== '\\';

        if (isSep && isNotEscaped) {
            // New cell
            if (i > 0 && i < trimmed.length) {
                cells.push(trimmed.slice(lastSep, i));
            }
            lastSep = i + 1;
        }
    }
    // Last cell
    if (lastSep < trimmed.length) {
        cells.push(trimmed.slice(lastSep));
    }

    return cells;
}

/**
 * Detect alignement per column
 *
 * @param {Array<String>}
 * @return {Array<String|null>}
 */
function mapAligns(aligns) {
    return aligns.map(function (s) {
        if (_table2.default.alignRight.test(s)) {
            return _.TABLE_ALIGN.RIGHT;
        } else if (_table2.default.alignCenter.test(s)) {
            return _.TABLE_ALIGN.CENTER;
        } else if (_table2.default.alignLeft.test(s)) {
            return _.TABLE_ALIGN.LEFT;
        }
        return null;
    });
}

/**
 * Render a row to text.
 *
 * @param {State} state
 * @param {Node} row
 * @return {String} text
 */
function rowToText(state, row) {
    var nodes = row.nodes;

    return '| ' + nodes.map(function (cell) {
        return cellToText(state, cell);
    }).join(' | ') + ' |';
}

/**
 * Render a cell to text.
 *
 * @param {State} state
 * @param {Node} row
 * @return {String} text
 */
function cellToText(state, cell) {
    var nodes = cell.nodes;

    // The cell may contain a single paragraph,
    // we just want to serialize the inner

    var nodesToSerialize = void 0;
    if (nodes.size === 1 && nodes.first().type === _.BLOCKS.PARAGRAPH) {
        nodesToSerialize = nodes.first().nodes;
    } else {
        nodesToSerialize = nodes;
    }

    return state.use('inline').serialize(nodesToSerialize);
}

/**
 * Render aligns of a table into a Markdown align row
 *
 * @param {Array<String>} aligns
 * @return {String}
 */
function alignsToText(aligns) {
    return '|' + aligns.map(function (align) {
        if (align == 'right') {
            return ' ---: |';
        } else if (align == 'center') {
            return ' :---: |';
        } else if (align == 'left') {
            return ' :--- |';
        }
        return ' --- |';
    }).join('');
}

/**
 * Render aligns of a table into a Markdown align row
 *
 * @param {Node} table
 * @return {Boolean}
 */
function mustSerializeAsHTML(table) {
    var isMultiBlockCell = function isMultiBlockCell(cell) {
        var nodes = cell.nodes;

        var containOneParagraph = nodes.size === 1 && nodes.first().type === _.BLOCKS.PARAGRAPH;
        var containInlines = nodes.every(function (child) {
            return child.object !== 'block';
        });

        return !containOneParagraph && !containInlines;
    };

    return table.findDescendant(function (node) {
        return node.type === _.BLOCKS.TABLE_CELL && isMultiBlockCell(node);
    });
}

exports.default = { serialize: serialize, deserialize: deserialize };