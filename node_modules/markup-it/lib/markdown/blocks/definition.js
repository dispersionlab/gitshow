'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _immutable = require('immutable');

var _ = require('../../');

var reDef = /^ {0,3}\[(.+)]:[ \t]*\n?[ \t]*<?(\S+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n+|(?=~0))/gm;

/**
 * Cleanup a text before parsing: normalize newlines and tabs
 *
 * @param {String} src
 * @return {String}
 */
function cleanupText(src) {
    return src.replace(/\r\n|\r/g, '\n').replace(/\t/g, '    ').replace(/\u00a0/g, ' ').replace(/\u2424/g, '\n').replace(/^ +$/gm, '');
}

/**
 * Deserialize all definitions in a markdown document and store them as
 * "refs" prop.
 * @type {Deserializer}
 */
var deserialize = (0, _.Deserializer)().then(function (state) {
    var depth = state.depth,
        nodes = state.nodes;
    var text = state.text;

    // Apply it as first rule only

    if (depth > 2 || nodes.size > 0 || state.getProp('refs')) {
        return undefined;
    }

    // Normalize the text
    text = cleanupText(text);

    var refs = {};

    // Parse all definitions
    text = text.replace(reDef, function (wholeMatch, linkId, href, width, height, blankLines, title) {
        refs[linkId.toLowerCase()] = {
            href: href,
            title: title
        };

        return '';
    });

    return state.replaceText(text).setProp('refs', (0, _immutable.Map)(refs));
});

exports.default = { deserialize: deserialize };