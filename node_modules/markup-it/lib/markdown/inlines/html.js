'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _htmlparser = require('htmlparser2');

var _htmlparser2 = _interopRequireDefault(_htmlparser);

var _immutable = require('immutable');

var _ = require('../../');

var _html = require('../../html');

var _html2 = _interopRequireDefault(_html);

var _inline = require('../re/inline');

var _inline2 = _interopRequireDefault(_inline);

var _HTML_BLOCKS = require('./HTML_BLOCKS');

var _HTML_BLOCKS2 = _interopRequireDefault(_HTML_BLOCKS);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Test if a tag name is an HTML block that should not be parsed inside
 * @param {String} tag
 * @return {Boolean}
 */
function isHTMLBlock(tag) {
    return _HTML_BLOCKS2.default.indexOf(tag.toLowerCase()) >= 0;
}

/**
 * Create a raw HTML node (inner Html not parsed)
 * @param {String} openingTag
 * @param {String} closingTag
 * @param {String} innerHtml
 * @param
 * @return {Inline}
 */
function createRawHTML(opts) {
    var _opts$openingTag = opts.openingTag,
        openingTag = _opts$openingTag === undefined ? '' : _opts$openingTag,
        _opts$closingTag = opts.closingTag,
        closingTag = _opts$closingTag === undefined ? '' : _opts$closingTag,
        _opts$innerHtml = opts.innerHtml,
        innerHtml = _opts$innerHtml === undefined ? '' : _opts$innerHtml;

    return _.Inline.create({
        type: _.INLINES.HTML,
        isVoid: true,
        data: { openingTag: openingTag, closingTag: closingTag, innerHtml: innerHtml }
    });
}

/**
 * Create an HTML node
 * @param {String} openingTag
 * @param {String} closingTag
 * @param {Node[]} nodes
 * @return {Inline}
 */
function createHTML(opts) {
    var _opts$openingTag2 = opts.openingTag,
        openingTag = _opts$openingTag2 === undefined ? '' : _opts$openingTag2,
        _opts$closingTag2 = opts.closingTag,
        closingTag = _opts$closingTag2 === undefined ? '' : _opts$closingTag2,
        nodes = opts.nodes;

    return _.Inline.create({
        type: _.INLINES.HTML,
        data: { openingTag: openingTag, closingTag: closingTag },
        nodes: nodes
    });
}

/**
 * Deserialize inline HTML
 * @param {String} html
 * @return {List<Node>} parsed nodes
 */
function deserializeHtml(html) {
    var htmlParser = _.State.create(_html2.default);
    var document = htmlParser.deserializeToDocument(html);
    var firstNode = document.nodes.first();
    var isEmpty = !firstNode || document.nodes.size === 1 && firstNode.type === _.BLOCKS.PARAGRAPH && firstNode.nodes.every(function (child) {
        return !child.isVoid;
    }) && firstNode.text === '';

    if (isEmpty) {
        return (0, _immutable.List)();
    }

    return firstNode.nodes;
}

/**
 * Serialize an HTML node to markdown
 * @type {Serializer}
 */
var serialize = (0, _.Serializer)().matchType(_.INLINES.HTML).then(function (state) {
    var node = state.peek();

    var _node$data$toObject = node.data.toObject(),
        _node$data$toObject$o = _node$data$toObject.openingTag,
        openingTag = _node$data$toObject$o === undefined ? '' : _node$data$toObject$o,
        _node$data$toObject$c = _node$data$toObject.closingTag,
        closingTag = _node$data$toObject$c === undefined ? '' : _node$data$toObject$c,
        _node$data$toObject$i = _node$data$toObject.innerHtml,
        innerHtml = _node$data$toObject$i === undefined ? '' : _node$data$toObject$i;

    if (innerHtml) {
        return state.shift().write(openingTag).write(innerHtml).write(closingTag);
    }
    return state.shift().write(openingTag).write(state.serialize(node.nodes)).write(closingTag);
});

/**
 * Deserialize HTML comment from markdown
 * @type {Deserializer}
 */
var deserializeComment = (0, _.Deserializer)().matchRegExp(_inline2.default.htmlComment, function (state, match) {
    return (
        // Ignore
        state
    );
});

/**
 * Deserialize HTML tag pair from markdown
 * @type {Deserializer}
 */
var deserializePair = (0, _.Deserializer)().matchRegExp(_inline2.default.htmlTagPair, function (state, match) {
    var _match = _slicedToArray(match, 4),
        fullTag = _match[0],
        tagName = _match[1],
        _match$ = _match[2],
        attributes = _match$ === undefined ? '' : _match$,
        _match$2 = _match[3],
        innerHtml = _match$2 === undefined ? '' : _match$2;

    var openingTag = '<' + tagName + attributes + '>';
    var closingTag = fullTag.slice(openingTag.length + innerHtml.length);

    // Finish parsing the inside of the HTML as Markdown
    var htmlNode = function () {
        if (isHTMLBlock(tagName)) {
            // Do not parse inner HTML
            return createRawHTML({
                openingTag: openingTag,
                closingTag: closingTag,
                innerHtml: innerHtml
            });
        }
        // else parse inner HTML as Markdown

        var isLink = tagName.toLowerCase() === 'a';
        var innerNodes = state.setProp(isLink ? 'link' : 'html', state.depth).deserialize(innerHtml);

        return createHTML({
            openingTag: openingTag,
            closingTag: closingTag,
            nodes: innerNodes
        });
    }();

    // Now convert everything back to HTML and interpret the whole
    // (we got rid of any Markdown)
    var htmlParser = _.State.create(_html2.default);
    var htmlOnly = htmlParser.use('block').serializeNode(htmlNode);

    return state
    // If we have found an anchor, store it so it is attached to the next heading
    .setProp('lastAnchorId', findHtmlAnchor(htmlOnly)).push(deserializeHtml(htmlOnly));
});

/**
 * Look for <a id="..."></a>, often used to
 * add custom anchors to Markdown headings.
 * @param {String} html
 * @return {String | Null} id of the anchor found
 */
function findHtmlAnchor(html) {
    var anchorId = null;

    var parser = new _htmlparser2.default.Parser({
        onopentag: function onopentag(tagName, attribs) {
            if (tagName.toLowerCase() === 'a' && attribs.id) {
                // This is an anchor with an ID
                anchorId = attribs.id;
            }
        }
    }, { decodeEntities: true });
    parser.write(html);
    parser.end();

    return anchorId;
}

/**
 * Deserialize HTML self closing tag from markdown
 * @type {Deserializer}
 */
var deserializeClosing = (0, _.Deserializer)().matchRegExp(_inline2.default.htmlSelfClosingTag, function (state, match) {
    var _match2 = _slicedToArray(match, 1),
        selfClosingHtml = _match2[0];

    return state.push(deserializeHtml(selfClosingHtml));
});

exports.default = {
    serialize: serialize,
    deserialize: (0, _.Deserializer)().use([deserializeComment, deserializePair, deserializeClosing])
};