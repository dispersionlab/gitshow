'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _detectNewline = require('detect-newline');

var _detectNewline2 = _interopRequireDefault(_detectNewline);

var _htmlparser = require('htmlparser2');

var _htmlparser2 = _interopRequireDefault(_htmlparser);

var _htmlclean = require('htmlclean');

var _htmlclean2 = _interopRequireDefault(_htmlclean);

var _immutable = require('immutable');

var _slate = require('@gitbook/slate');

var _ = require('../');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var INLINE_TAGS = {
    a: _.INLINES.LINK,
    img: _.INLINES.IMAGE
};

var BLOCK_TAGS = {
    h1: _.BLOCKS.HEADING_1,
    h2: _.BLOCKS.HEADING_2,
    h3: _.BLOCKS.HEADING_3,
    h4: _.BLOCKS.HEADING_4,
    h5: _.BLOCKS.HEADING_5,
    h6: _.BLOCKS.HEADING_6,
    pre: _.BLOCKS.CODE,
    blockquote: _.BLOCKS.BLOCKQUOTE,
    p: _.BLOCKS.PARAGRAPH,
    hr: _.BLOCKS.HR,

    table: _.BLOCKS.TABLE,
    tr: _.BLOCKS.TABLE_ROW,
    th: _.BLOCKS.TABLE_CELL,
    td: _.BLOCKS.TABLE_CELL,

    ul: _.BLOCKS.UL_LIST,
    ol: _.BLOCKS.OL_LIST,
    li: _.BLOCKS.LIST_ITEM
};

var MARK_TAGS = {
    b: _.MARKS.BOLD,
    strong: _.MARKS.BOLD,
    del: _.MARKS.STRIKETHROUGH,
    em: _.MARKS.ITALIC,
    code: _.MARKS.CODE
};

var MARK_CLASSNAME = {
    'line-through': _.MARKS.STRIKETHROUGH
};

var TAGS_TO_DATA = {
    a: function a(attribs) {
        return {
            href: attribs.href,
            title: attribs.alt || ''
        };
    },
    img: function img(attribs) {
        return {
            src: attribs.src,
            title: attribs.alt || ''
        };
    },

    h1: resolveHeadingAttrs,
    h2: resolveHeadingAttrs,
    h3: resolveHeadingAttrs,
    h4: resolveHeadingAttrs,
    h5: resolveHeadingAttrs,
    h6: resolveHeadingAttrs
};

function resolveHeadingAttrs(attribs) {
    return attribs.id ? { id: attribs.id } : {};
}

/**
 * Flatten a block node into a list of inline nodes.
 * @param  {Node} node
 * @return {List<Node>} nodes
 */
function selectInlines(node) {
    if (node.object !== 'block') {
        return (0, _immutable.List)([node]);
    }

    var nodes = node.nodes;

    return nodes.reduce(function (result, child) {
        return result.concat(selectInlines(child));
    }, (0, _immutable.List)());
}

/**
 * Get all marks from a class name.
 * @param {String} className
 * @return {Array<Mark>}
 */
function getMarksForClassName() {
    var className = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

    var classNames = className.split(' ');
    var result = [];

    classNames.forEach(function (name) {
        var type = MARK_CLASSNAME[name];
        if (!type) {
            return;
        }

        var mark = _.Mark.create({
            type: type
        });
        result.push(mark);
    });

    return result;
}

/**
 * Returns the accepted block types for the given container
 */
function acceptedBlocks(container) {
    return _.CONTAINERS[container.type || container.object];
}

/**
 * True if the node is a block container node
 */
function isBlockContainer(node) {
    return Boolean(acceptedBlocks(node));
}

/**
 * Returns the default block type for a block container
 */
function defaultBlockType(container) {
    return acceptedBlocks(container)[0];
}

/**
 * True if `block` can contain `node`
 */
function canContain(block, node) {
    if (node.object === 'inline' || node.object === 'text') {
        return _.LEAFS[block.type];
    }
    var types = acceptedBlocks(block);
    return types && types.indexOf(node.type) !== -1;
}

/*
 * sanitizeSpaces replace non-breaking spaces with regular space
 * non-breaking spaces (aka &nbsp;) are sources of many problems & quirks
 * &nbsp; in ascii is `0xA0` or `0xC2A0` in utf8
 * @param {String} str
 * @return {String}
 */
function sanitizeSpaces(str) {
    return str.replace(/\xa0/g, ' ');
}

/**
 * @param {String} tagName The tag name
 * @param {Object} attrs The tag's attributes
 * @return {Object} data
 */
function getData(tagName, attrs) {
    return (TAGS_TO_DATA[tagName] || function () {})(attrs);
}

/**
 * @param {String} nodeType
 * @return {Boolean} isVoid
 */
function isVoid(nodeType) {
    return Boolean(_.VOID[nodeType]);
}

/**
 * Returns the list of lines in the string
 * @param {String} text
 * @param {String} sep?
 * @return {List<String>}
 */
function splitLines(text) {
    var sep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, _detectNewline2.default)(text) || '\n';

    return (0, _immutable.List)(text.split(sep));
}

/**
 * Update the node on top of the stack with the given node
 * @param {Stack} stack
 * @param {Node} node
 * @return {Stack}
 */
function setNode(stack, node) {
    return stack.pop().push(node);
}

/**
 * Append a node child to the current parent node
 * @param {Stack} stack
 * @param {Node} node
 * @return {Stack}
 */
function appendNode(stack, node) {
    var parent = stack.peek();
    var nodes = parent.nodes;

    // If parent is not a block container

    if (!isBlockContainer(parent) && node.object == 'block') {
        // Discard all blocks
        nodes = nodes.concat(selectInlines(node));
    }

    // Wrap node if type is not allowed
    else if (isBlockContainer(parent) && (node.object !== 'block' || !canContain(parent, node))) {
            var previous = parent.nodes.last();
            if (previous && canContain(previous, node)) {
                // Reuse previous block if possible
                nodes = nodes.pop().push(previous.set('nodes', previous.nodes.push(node)));
            } else {
                // Else insert a default wrapper
                var wrapper = _.Block.create({
                    type: defaultBlockType(parent),
                    nodes: [node]
                });

                nodes = nodes.push(wrapper);
            }
        } else {
            nodes = nodes.push(node);
        }

    return setNode(stack, parent.merge({ nodes: nodes }));
}

/**
 * Push a new node, as current parent. We started parsing it
 * @param {Stack} stack
 * @param {Node} node
 * @return {Stack}
 */
function pushNode(stack, node) {
    return stack.push(node);
}

/**
 * Pop the current parent node. Because we're done parsing it
 * @param {Stack} stack
 * @return {Stack}
 */
function popNode(stack) {
    return appendNode(stack.pop(), stack.peek());
}

/**
 * Parse an HTML string into a document
 * @param {String} str
 * @return {Document}
 */
function parse(str) {
    // Cleanup whitespaces
    var cleanedUpStr = (0, _htmlclean2.default)(str);

    // For convenience, starts with a root node
    var root = _slate.Document.create({});
    // The top of the stack always hold the current parent
    // node. Should never be empty.
    var stack = (0, _immutable.Stack)().push(root);
    // The current marks
    var marks = (0, _immutable.Set)();

    var parser = new _htmlparser2.default.Parser({
        onopentag: function onopentag(tagName, attribs) {
            if (BLOCK_TAGS[tagName]) {
                var type = BLOCK_TAGS[tagName];
                var block = _.Block.create({
                    data: getData(tagName, attribs),
                    isVoid: isVoid(type),
                    type: type
                });

                stack = pushNode(stack, block);
            } else if (INLINE_TAGS[tagName]) {
                var _type = INLINE_TAGS[tagName];
                var inline = _.Inline.create({
                    data: getData(tagName, attribs),
                    isVoid: isVoid(_type),
                    type: _type
                });

                stack = pushNode(stack, inline);
            } else if (MARK_TAGS[tagName]) {
                var mark = _.Mark.create({
                    data: getData(tagName, attribs),
                    type: MARK_TAGS[tagName]
                });

                marks = marks.add(mark);
            } else if (tagName == 'br') {
                var textNode = _.Text.create({
                    text: '\n',
                    marks: marks
                });
                stack = appendNode(stack, textNode);
            }
            // else ignore

            // Parse marks from the class name
            var newMarks = getMarksForClassName(attribs.class);
            marks = marks.concat(newMarks);
        },
        ontext: function ontext(text) {
            var cleanText = sanitizeSpaces(text);
            var textNode = _.Text.create({ text: cleanText, marks: marks });
            stack = appendNode(stack, textNode);
        },
        onclosetag: function onclosetag(tagName) {
            if (BLOCK_TAGS[tagName] || INLINE_TAGS[tagName]) {
                var parent = stack.peek();

                // Special rule for code blocks that we must split in lines
                if (parent.type === _.BLOCKS.CODE) {
                    var lines = splitLines(parent.text);
                    // Remove trailing newline
                    if (lines.last().trim() === '') {
                        lines = lines.skipLast(1);
                    }
                    stack = setNode(stack, parent.merge({
                        nodes: lines.map(function (line) {
                            return (
                                // Create a code line
                                _.Block.create({
                                    type: _.BLOCKS.CODE_LINE,
                                    nodes: [_.Text.create(line)]
                                })
                            );
                        })
                    }));
                }

                stack = popNode(stack);
            } else if (MARK_TAGS[tagName]) {
                var type = MARK_TAGS[tagName];
                marks = marks.filter(function (mark) {
                    return mark.type !== type;
                });
            }
            // else ignore
        }
    }, {
        decodeEntities: true
    });

    parser.write(cleanedUpStr);
    parser.end();

    if (stack.size !== 1) {
        throw new Error('Invalid HTML. A tag might not have been closed correctly.');
    }

    return stack.peek();
}

exports.default = parse;